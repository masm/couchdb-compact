var _ = require("lodash");
var http = require("http");
var utils = require("masm-util");

function Server(host, port, authStr, authSessionCookie, agent) {
    this.host = host;
    this.port = port;
    this.authStr = authStr;
    this.authSessionCookie = authSessionCookie;
    this.agent = agent === false ? agent : agent || http.globalAgent;
}

Server.prototype = {
    withProxy: function (host, port) {
        this.useProxy = true;
        this.proxiedHost = this.host;
        this.host = host;
        this.proxiedPort = this.port;
        this.port = port;
    },

    url: function (path, query) {
        if (this.useProxy) {
            var hostAndPort = this.proxiedPort === 80 ? this.proxiedHost : this.proxiedHost + ":" + this.proxiedPort;
            return utils.url("http://" + hostAndPort + path, query);
        } else {
            return utils.url(path, query);
        }
    },

    cloneWithoutAgent: function () {
        return new Server(this.host, this.port, this.authStr, this.authSessionCookie, false);
    },

    request: function(method, path, query, callback, data) {
        method = method.toUpperCase();
        var req = http.request({
            agent: this.agent,
            host: this.host,
            port: this.port,
            path: this.url(path, query),
            method: method,
            headers: this.defaultHeadersForMethod(method, data)
        }, callback);
        if (data) {
            req.end(data);
        } else {
            // don't send data
        }
        return req;
    },

    requestWithHeaders: function(method, path, query, headers, callback, data) {
        method = method.toUpperCase();
        var req = http.request({
            agent: this.agent,
            host: this.host,
            port: this.port,
            path: this.url(path, query),
            method: method,
            headers: _.extend(this.defaultHeadersForMethod(method, data), headers)
        }, callback);
        if (data) {
            req.end(data);
        } else {
            // don't send data
        }
        return req;
    },

    get: function(path, query, callback) {
        return http.get({
            agent: this.agent,
            host: this.host,
            port: this.port,
            path: this.url(path, query),
            headers: this.defaultHeadersForMethod("GET")
        }, callback);
    },

    getWithHeaders: function(path, query, headers, callback) {
        return http.get({
            agent: this.agent,
            host: this.host,
            port: this.port,
            path: this.url(path, query),
            headers: _.extend(this.defaultHeadersForMethod("GET"), headers)
        }, callback);
    },

    put: function(path, query, callback) {
        return this.request("PUT", path, query, callback);
    },

    putWithHeaders: function(path, query, headers, callback) {
        return this.requestWithHeaders("PUT", path, query, headers, callback);
    },

    post: function(path, query, callback) {
        return this.request("POST", path, query, callback);
    },

    postWithHeaders: function(path, query, headers, callback) {
        return this.request("POST", path, query, headers, callback);
    },

    delete: function(path, query, callback) {
        var req = this.request("DELETE", path, query, callback);
        req.end();
        return req;
    },

    deleteWithHeaders: function(path, query, headers, callback) {
        var req = this.request("DELETE", path, query, headers, callback);
        req.end();
        return req;
    },

    requestJSON: function(method, path, query, callback, end) {
        var req = this.request(method, path, query, utils.withJSONFromBody(function (data) {
            if (data.error) {
                return callback(data, null);
            } else {
                return callback(null, data);
            }
        }), (!end && end !== "") ? end : new Buffer(end));
        req.on("error", function(e) {
            callback({error:"internal server error", reason: "access to couchdb failed", message: e.message});
        });
        return req;
    },

    requestJSONWithHeaders: function(method, path, query, headers, callback, end) {
        var req = this.requestWithHeaders(method, path, query, headers, utils.withJSONFromBody(function (data) {
            if (data.error) {
                return callback(data, null);
            } else {
                return callback(null, data);
            }
        }), (!end && end !== "") ? end : new Buffer(end));
        req.on("error", function(e) {
            callback({error:"internal server error", reason: "access to couchdb failed", message: e.message});
        });
        return req;
    },

    getJSON: function(path, query, callback) {
        var req = this.get(path, query, utils.withJSONFromBody(function (data) {
            if (data.error) {
                return callback(data, null);
            } else {
                return callback(null, data);
            }
        }));
        req.on("error", function(e) {
            callback({error:"internal server error", reason: "access to couchdb failed", message: e.message});
        });
        return req;
    },

    getJSONWithHeaders: function(path, query, headers, callback) {
        var req = this.getWithHeaders(path, query, headers, utils.withJSONFromBody(function (data) {
            if (data.error) {
                return callback(data, null);
            } else {
                return callback(null, data);
            }
        }));
        req.on("error", function(e) {
            callback({error:"internal server error", reason: "access to couchdb failed", message: e.message});
        });
        return req;
    },

    putJSON: function(path, query, callback, end) {
        return this.requestJSON("PUT", path, query, callback, end);
    },

    putJSONWithHeaders: function(path, query, headers, callback, end) {
        return this.requestJSONWithHeaders("PUT", path, query, headers, callback, end);
    },

    postJSON: function(path, query, callback, end) {
        return this.requestJSON("POST", path, query, callback, end);
    },

    postJSONWithHeaders: function(path, query, headers, callback, end) {
        return this.requestJSONWithHeaders("POST", path, query, headers, callback, end);
    },

    deleteJSON: function(path, query, callback) {
        return this.requestJSON("DELETE", path, query, callback, "");
    },

    deleteJSONWithHeaders: function(path, query, headers, callback) {
        return this.requestJSONWithHeaders("DELETE", path, query, headers, callback, "");
    },

    defaultHeadersForMethod: function (method, data) {
        var o = {"Accept": "application/json"};
        if (this.authStr) {
            _.extend(o, {"Authorization": this.authStr});
        } else if (this.authSessionCookie) {
            _.extend(o, {Cookie: "AuthSession=" + this.authSessionCookie});
        } else {
            // do nothing
        }
        if (data) {
            _.extend(o, {"Content-Length": data.length});
        }
        switch (method.toUpperCase()) {
        case "PUT": case "POST":
            _.extend(o, {"Content-Type": "application/json"});
            break;
        default:
            break;
        }
        if (this.useProxy) {
            _.extend(o, {Host: this.proxiedHost});
        }
        return o;
    }
};

function connection (host, port, username, password, agent) {
    var authStr;
    if (username) {
        authStr = "Basic " + new Buffer(username + ":" + password).toString("base64");
    } else {
        authStr = null;
    }

    return new Server(host, port, authStr, null, agent);
}

function connectionWithAuthSessionCookie (host, port, cookie, agent) {
    return new Server(host, port, null, cookie, agent);
}

module.exports = {
    connection: connection,
    connectionWithAuthSessionCookie: connectionWithAuthSessionCookie
};
